#!/usr/bin/env node

/**
 * Apply Tag Suggestions to Gallery JSON Files
 * 
 * This script applies the tag suggestions generated by auto-tag.js
 * to the actual gallery JSON data files.
 * 
 * Usage:
 *   node scripts/apply-tags.js <suggestion-file>
 *   node scripts/apply-tags.js landscapes-2025-11-25T10-30-00.json
 *   node scripts/apply-tags.js <suggestion-file> --dry-run    # Preview changes
 *   node scripts/apply-tags.js <suggestion-file> --tags-only  # Only apply tags, not titles
 * 
 * Before running:
 *   1. Review the suggestion file in scripts/tag-suggestions/
 *   2. Edit any incorrect suggestions
 *   3. Remove entries you don't want to apply
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.join(__dirname, '..');

/**
 * Load a suggestion file
 */
async function loadSuggestions(filename) {
  const suggestionsDir = path.join(PROJECT_ROOT, 'scripts/tag-suggestions');
  const filePath = filename.includes('/') 
    ? filename 
    : path.join(suggestionsDir, filename);
  
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    console.error(`‚ùå Could not load suggestion file: ${filePath}`);
    console.error(`   ${error.message}`);
    process.exit(1);
  }
}

/**
 * Load a gallery JSON file
 */
async function loadGalleryData(category) {
  const jsonPath = path.join(PROJECT_ROOT, 'src/data', `${category}.json`);
  const content = await fs.readFile(jsonPath, 'utf-8');
  return { data: JSON.parse(content), path: jsonPath };
}

/**
 * Create a backup of a file
 */
async function createBackup(filePath) {
  const backupDir = path.join(PROJECT_ROOT, 'scripts/backups');
  await fs.mkdir(backupDir, { recursive: true });
  
  const filename = path.basename(filePath);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const backupPath = path.join(backupDir, `${filename}.${timestamp}.backup`);
  
  await fs.copyFile(filePath, backupPath);
  return backupPath;
}

/**
 * Apply suggestions to gallery data
 */
async function applySuggestions(suggestions, options = {}) {
  const { dryRun = false, tagsOnly = false } = options;
  
  // Group suggestions by category
  const byCategory = {};
  for (const suggestion of suggestions.suggestions) {
    const cat = suggestion.category;
    if (!byCategory[cat]) byCategory[cat] = [];
    byCategory[cat].push(suggestion);
  }
  
  let totalUpdated = 0;
  const changes = [];
  
  for (const [category, categorySuggestions] of Object.entries(byCategory)) {
    console.log(`\nüìÅ Processing ${category}...`);
    
    const { data, path: jsonPath } = await loadGalleryData(category);
    let categoryUpdated = 0;
    
    for (const suggestion of categorySuggestions) {
      // Find the image in the gallery data
      const imageIndex = data.images.findIndex(img => img.src === suggestion.src);
      
      if (imageIndex === -1) {
        console.log(`   ‚ö†Ô∏è  Image not found in ${category}: ${suggestion.src}`);
        continue;
      }
      
      const image = data.images[imageIndex];
      const imageChanges = { src: suggestion.src, updates: {} };
      
      // Apply tags
      if (suggestion.suggested_tags && suggestion.suggested_tags.length > 0) {
        const oldTags = image.tags || [];
        const newTags = suggestion.suggested_tags;
        
        if (JSON.stringify(oldTags.sort()) !== JSON.stringify(newTags.sort())) {
          imageChanges.updates.tags = { from: oldTags, to: newTags };
          if (!dryRun) {
            data.images[imageIndex].tags = newTags;
          }
        }
      }
      
      // Apply title (unless tags-only mode)
      if (!tagsOnly && suggestion.suggested_title) {
        const oldTitle = image.title;
        const newTitle = suggestion.suggested_title;
        
        if (oldTitle !== newTitle) {
          imageChanges.updates.title = { from: oldTitle, to: newTitle };
          if (!dryRun) {
            data.images[imageIndex].title = newTitle;
          }
        }
      }
      
      // Apply alt text (unless tags-only mode)
      if (!tagsOnly && suggestion.suggested_alt) {
        const oldAlt = image.alt;
        const newAlt = suggestion.suggested_alt;
        
        if (oldAlt !== newAlt) {
          imageChanges.updates.alt = { from: oldAlt, to: newAlt };
          if (!dryRun) {
            data.images[imageIndex].alt = newAlt;
          }
        }
      }
      
      // Track changes
      if (Object.keys(imageChanges.updates).length > 0) {
        changes.push(imageChanges);
        categoryUpdated++;
        
        // Print change summary
        console.log(`   ‚úì ${path.basename(suggestion.src)}`);
        if (imageChanges.updates.tags) {
          console.log(`     Tags: ${imageChanges.updates.tags.to.join(', ')}`);
        }
        if (imageChanges.updates.title) {
          console.log(`     Title: "${imageChanges.updates.title.to}"`);
        }
      }
    }
    
    // Save updated data
    if (!dryRun && categoryUpdated > 0) {
      // Create backup first
      const backupPath = await createBackup(jsonPath);
      console.log(`   üì¶ Backup: ${path.relative(PROJECT_ROOT, backupPath)}`);
      
      // Write updated data
      await fs.writeFile(jsonPath, JSON.stringify(data, null, 2));
      console.log(`   üíæ Saved ${categoryUpdated} updates to ${category}.json`);
    }
    
    totalUpdated += categoryUpdated;
  }
  
  return { totalUpdated, changes };
}

/**
 * Main function
 */
async function main() {
  console.log('\nüè∑Ô∏è  Anu Photography - Apply Tag Suggestions\n');
  console.log('‚ïê'.repeat(50));
  
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args.includes('--help')) {
    console.log(`
Usage:
  node scripts/apply-tags.js <suggestion-file>
  node scripts/apply-tags.js <suggestion-file> --dry-run
  node scripts/apply-tags.js <suggestion-file> --tags-only

Options:
  --dry-run     Preview changes without applying them
  --tags-only   Only apply tags, not title/alt suggestions
  --help        Show this help message

Example:
  node scripts/apply-tags.js landscapes-2025-11-25T10-30-00.json
`);
    
    // List available suggestion files
    const suggestionsDir = path.join(PROJECT_ROOT, 'scripts/tag-suggestions');
    try {
      const files = await fs.readdir(suggestionsDir);
      const jsonFiles = files.filter(f => f.endsWith('.json'));
      if (jsonFiles.length > 0) {
        console.log('Available suggestion files:');
        for (const file of jsonFiles) {
          console.log(`  - ${file}`);
        }
      }
    } catch (e) {
      // Directory might not exist yet
    }
    
    return;
  }
  
  const filename = args.find(a => !a.startsWith('--'));
  const dryRun = args.includes('--dry-run');
  const tagsOnly = args.includes('--tags-only');
  
  if (!filename) {
    console.error('‚ùå Please provide a suggestion file name');
    process.exit(1);
  }
  
  console.log(`üìÑ Loading: ${filename}`);
  if (dryRun) console.log('   (Dry run - no changes will be made)');
  if (tagsOnly) console.log('   (Tags only - titles/alts will not be changed)');
  
  const suggestions = await loadSuggestions(filename);
  console.log(`   Found ${suggestions.suggestions.length} suggestions`);
  
  const { totalUpdated, changes } = await applySuggestions(suggestions, { dryRun, tagsOnly });
  
  console.log('\n' + '‚ïê'.repeat(50));
  if (dryRun) {
    console.log(`üìã Dry run complete: ${totalUpdated} images would be updated`);
    console.log('   Run without --dry-run to apply changes');
  } else {
    console.log(`‚úÖ Done! Updated ${totalUpdated} images`);
  }
  console.log();
}

main().catch(console.error);
